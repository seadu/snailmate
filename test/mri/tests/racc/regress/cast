#
# DO NOT MODIFY!!!!
# This file is automatically generated by Racc 1.5.2
# from Racc grammar file "".
#

require 'racc/parser.rb'


require 'set'

# Error classes
module C
  class ParseError < StandardError; end
end

# Local variables:
#   mode: ruby
# end:
module C
  class Parser < Racc::Parser

module_eval(<<'...end cast.y/module_eval...', 'cast.y', 564)
  # A.1.9 -- Preprocessing numbers -- skip
  # A.1.8 -- Header names -- skip

  # A.1.7 -- Puncuators -- we don't bother with {##,#,%:,%:%:} since
  # we don't do preprocessing
  @@punctuators = %r'\+\+|-[->]|&&|\|\||\.\.\.|(?:<<|>>|[<>=!*/%+\-&^|])=?|[\[\](){}.~?:;,]'
  @@digraphs    = %r'<[:%]|[:%]>'

  # A.1.6 -- String Literals -- simple for us because we don't decode
  # the string (and indeed accept some illegal strings)
  @@string_literal = %r'L?"(?:[^\\]|\\.)*?"'m

  # A.1.5 -- Constants
  @@decimal_floating_constant     = %r'(?:(?:\d*\.\d+|\d+\.)(?:e[-+]?\d+)?|\d+e[-+]?\d+)[fl]?'i
  @@hexadecimal_floating_constant = %r'0x(?:(?:[0-9a-f]*\.[0-9a-f]+|[0-9a-f]+\.)|[0-9a-f]+)p[-+]?\d+[fl]?'i

  @@integer_constant     = %r'(?:[1-9][0-9]*|0x[0-9a-f]+|0[0-7]*)(?:ul?l?|ll?u?)?'i
  @@floating_constant    = %r'#{@@decimal_floating_constant}|#{@@hexadecimal_floating_constant}'
  @@enumeration_constant = %r'[a-zA-Z_\\][a-zA-Z_\\0-9]*'
  @@character_constant   = %r"L?'(?:[^\\]|\\.)+?'"
  # (note that as with string-literals, we accept some illegal
  # character-constants)

  # A.1.4 -- Universal character names -- skip

  # A.1.3 -- Identifiers -- skip, since an identifier is lexically
  # identical to an enumeration constant

  # A.1.2 Keywords
  keywords = %w'auto break case char const continue default do
double else enum extern float for goto if inline int long register
restrict return short signed sizeof static struct switch typedef union
 unsigned void volatile while _Bool _Complex _Imaginary'
  @@keywords = %r"#{keywords.join('|')}"

  def initialize
    @type_names = ::Set.new

    @warning_proc = lambda{}
    @pos          = C::Node::Pos.new(nil, 1, 0)
  end
  def initialize_copy(x)
    @pos        = x.pos.dup
    @type_names = x.type_names.dup
  end
  attr_accessor :pos, :type_names

  def parse(str)
    if str.respond_to? :read
      str = str.read
    end
    @str = str
    begin
      prepare_lexer(str)
      return do_parse
    rescue ParseError => e
      e.set_backtrace(caller)
      raise
    end
  end

  #
  # Error handler, as used by racc.
  #
  def on_error(error_token_id, error_value, value_stack)
    if error_value == '$'
      parse_error @pos, "unexpected EOF"
    else
      parse_error(error_value.pos,
                  "parse error on #{token_to_str(error_token_id)} (#{error_value.val})")
    end
  end

  def self.feature(name)
    attr_writer "#{name}_enabled"
    class_eval <<-EOS
      def enable_#{name}
        @#{name}_enabled = true
      end
      def #{name}_enabled?
        @#{name}_enabled
      end
    EOS
  end
  private_class_method :feature

  #
  # Allow blocks in parentheses as expressions, as per the gcc
  # extension.  [http://rubyurl.com/iB7]
  #
  feature :block_expressions

  private  # ---------------------------------------------------------

  class Token
    attr_accessor :pos, :val
    def initialize(pos, val)
      @pos = pos
      @val = val
    end
  end
  def eat(str)
    lines = str.split(/\r\n|[\r\n]/, -1)
    if lines.length == 1
      @pos.col_num += lines[0].length
    else
      @pos.line_num += lines.length - 1
      @pos.col_num = lines[-1].length
    end
  end

  #
  # Make a Declaration from the given specs and declarators.
  #
  def make_declaration(pos, specs, declarators)
    specs.all?{|x| x.is_a?(Symbol) || x.is_a?(Type)} or raise specs.map{|x| x.class}.inspect
    decl = Declaration.new_at(pos, nil, declarators)

    # set storage class
    storage_classes = specs.find_all do |x|
      [:typedef, :extern, :static, :auto, :register].include? x
    end
    # 6.7.1p2: at most, one storage-class specifier may be given in
    # the declaration specifiers in a declaration
    storage_classes.length <= 1 or
      begin
        if declarators.length == 0
          for_name = ''
        else
          for_name = "for `#{declarators[0].name}'"
        end
        parse_error pos, "multiple or duplicate storage classes given #{for_name}'"
      end
    decl.storage = storage_classes[0]

    # set type (specifiers, qualifiers)
    decl.type = make_direct_type(pos, specs)

    # set function specifiers
    decl.inline = specs.include?(:inline)

    # look for new type names
    if decl.typedef?
      decl.declarators.each do |d|
        if d.name
          @type_names << d.name
        end
      end
    end

    return decl
  end

  def make_function_def(pos, specs, func_declarator, decl_list, defn)
    add_decl_type(func_declarator, make_direct_type(pos, specs))

    # get types from decl_list if necessary
    function = func_declarator.indirect_type
    function.is_a? Function or
      parse_error pos, "non function type for function `#{func_declarator.name}'"
    params = function.params
    if decl_list
      params.all?{|p| p.type.nil?} or
        parse_error pos, "both prototype and declaration list given for `#{func_declarator.name}'"
      decl_list.each do |declaration|
        declaration.declarators.each do |declarator|
          param = params.find{|p| p.name == declarator.name} or
            parse_error pos, "no parameter named #{declarator.name}"
          if declarator.indirect_type
            param.type = declarator.indirect_type
            param.type.direct_type = declaration.type.dup
          else
            param.type = declaration.type.dup
          end
        end
      end
      params.all?{|p| p.type} or
        begin
          s = params.find_all{|p| p.type.nil?}.map{|p| "`#{p.name}'"}.join(' and ')
          parse_error pos, "types missing for parameters #{s}"
        end
    end

    fd = FunctionDef.new_at(pos,
                            function.detach,
                            func_declarator.name,
                            defn,
                            :no_prototype => !decl_list.nil?)

    # set storage class
    # 6.9.1p4: only extern or static allowed
    specs.each do |s|
      [:typedef, :auto, :register].include?(s) and
        "`#{s}' illegal for function"
    end
    storage_classes = specs.find_all do |s|
      s == :extern || s == :static
    end
    # 6.7.1p2: at most, one storage-class specifier may be given in
    # the declaration specifiers in a declaration
    storage_classes.length <= 1 or
      "multiple or duplicate storage classes given for `#{func_declarator.name}'"
    fd.storage = storage_classes[0] if storage_classes[0]

    # set function specifiers
    # 6.7.4p5 'inline' can be repeated
    fd.inline = specs.include?(:inline)

    return fd
  end

  #
  # Make a direct type from the list of type specifiers and type
  # qualifiers.
  #
  def make_direct_type(pos, specs)
    specs_order = [:signed, :unsigned, :short, :long, :double, :void,
      :char, :int, :float, :_Bool, :_Complex, :_Imaginary]

    type_specs = specs.find_all do |x|
      specs_order.include?(x) || !x.is_a?(Symbol)
    end
    type_specs.sort! do |a, b|
      (specs_order.index(a)||100) <=> (specs_order.index(b)||100)
    end

    # set type specifiers
    # 6.7.2p2: the specifier list should be one of these
    type =
      case type_specs
      when [:void]
        Void.new
      when [:char]
        Char.new
      when [:signed, :char]
        Char.new :signed => true
      when [:unsigned, :char]
        Char.new :signed => false
      when [:short], [:signed, :short], [:short, :int],
        [:signed, :short, :int]
        Int.new :longness => -1
      when [:unsigned, :short], [:unsigned, :short, :int]
        Int.new :unsigned => true, :longness => -1
      when [:int], [:signed], [:signed, :int]
        Int.new
      when [:unsigned], [:unsigned, :int]
        Int.new :unsigned => true
      when [:long], [:signed, :long], [:long, :int],
        [:signed, :long, :int]
        Int.new :longness => 1
      when [:unsigned, :long], [:unsigned, :long, :int]
        Int.new :longness => 1, :unsigned => true
      when [:long, :long], [:signed, :long, :long],
        [:long, :long, :int], [:signed, :long, :long, :int]
        Int.new :longness => 2
      when [:unsigned, :long, :long], [:unsigned, :long, :long, :int]
        Int.new :longness => 2, :unsigned => true
      when [:float]
        Float.new
      when [:double]
        Float.new :longness => 1
      when [:long, :double]
        Float.new :longness => 2
      when [:_Bool]
        Bool.new
      when [:float, :_Complex]
        Complex.new
      when [:double, :_Complex]
        Complex.new :longness => 1
      when [:long, :double, :_Complex]
        Complex.new :longness => 2
      when [:float, :_Imaginary]
        Imaginary.new
      when [:double, :_Imaginary]
        Imaginary.new :longness => 1
      when [:long, :double, :_Imaginary]
        Imaginary.new :longness => 2
      else
        if type_specs.length == 1 &&
            [CustomType, Struct, Union, Enum].any?{|c| type_specs[0].is_a? c}
          type_specs[0]
        else
          if type_specs == []
            parse_error pos, "no type specifiers given"
          else
            parse_error pos, "invalid type specifier combination: #{type_specs.join(' ')}"
          end
        end
      end
    type.pos ||= pos

    # set type qualifiers
    # 6.7.3p4: type qualifiers can be repeated
    type.const    = specs.any?{|x| x.equal? :const   }
    type.restrict = specs.any?{|x| x.equal? :restrict}
    type.volatile = specs.any?{|x| x.equal? :volatile}

    return type
  end

  def make_parameter(pos, specs, indirect_type, name)
    type = indirect_type
    if type
      type.direct_type = make_direct_type(pos, specs)
    else
      type = make_direct_type(pos, specs)
    end
    [:typedef, :extern, :static, :auto, :inline].each do |sym|
      specs.include? sym and
        parse_error pos, "parameter `#{declarator.name}' declared `#{sym}'"
    end
    return Parameter.new_at(pos, type, name,
                            :register => specs.include?(:register))
  end

  def add_type_quals(type, quals)
    type.const    = quals.include?(:const   )
    type.restrict = quals.include?(:restrict)
    type.volatile = quals.include?(:volatile)
    return type
  end

  #
  # Add te given type as the "most direct" type to the given
  # declarator.  Return the declarator.
  #
  def add_decl_type(declarator, type)
    if declarator.indirect_type
      declarator.indirect_type.direct_type = type
    else
      declarator.indirect_type = type
    end
    return declarator
  end

  def param_list(params, var_args)
    if params.length == 1 &&
        params[0].type.is_a?(Void) &&
        params[0].name.nil?
      return NodeArray[]
    elsif params.empty?
      return nil
    else
      return params
    end
  end

  def parse_error(pos, str)
    raise ParseError, "#{pos}: #{str}"
  end

...end cast.y/module_eval...
##### State transition tables begin ###

racc_action_table = [
    99,   100,    65,   103,   108,   109,   120,   312,    61,   110,
   111,   112,   113,   114,   115,   116,   117,    77,    48,    10,
    11,    12,    13,    14,    15,    16,    17,    18,    19,    20,
    21,    22,    23,    24,    25,    26,    31,    32,    33,    34,
    35,    36,    37,    72,   281,   128,    49,    38,   196,   391,
   123,   124,   126,   127,   129,   130,   131,   132,   183,   277,
    83,   273,    84,   238,   288,   293,    88,   196,    72,   290,
    38,   274,   184,   372,   373,   386,   239,   240,   289,   294,
    71,   241,   242,    50,   147,   148,   149,   150,    99,   100,
    65,   193,   108,   109,   120,    50,   281,   110,   111,   112,
   113,   114,   115,   116,   117,    71,    50,    10,    11,    12,
    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,
    23,    24,    25,    26,    31,    32,    33,    34,    35,    36,
    37,    56,   366,   128,    89,    38,    50,   169,   123,   124,
   126,   127,   129,   130,   131,   132,    99,   100,    65,    88,
   108,   109,   120,    88,    88,   110,   111,   112,   113,   114,
   115,   116,   117,   346,   349,   238,    59,    68,    48,   365,
   195,    50,   147,   148,   149,   150,    38,   347,   239,   240,
    69,   178,   283,   196,   312,   366,   243,   244,    48,   262,
    88,   128,   185,    38,   263,   284,   123,   124,   126,   127,
   129,   130,   131,   132,    99,   100,    65,    49,   108,   109,
   120,    38,    50,   110,   111,   112,   113,   114,   115,   116,
   117,   281,   365,   309,   440,   249,   250,    49,   238,    50,
   147,   148,   149,   150,   313,   379,   196,   227,   439,   178,
   413,   239,   240,    88,   196,    50,    48,    50,   196,   128,
   187,    38,   191,   196,   123,   124,   126,   127,   129,   130,
   131,   132,    99,   100,    65,    50,   108,   109,   120,   416,
   428,   110,   111,   112,   113,   114,   115,   116,   117,   255,
   256,   192,   196,   196,   197,    49,   198,    50,   147,   148,
   149,   150,   228,   229,   230,   231,   232,   233,   234,   235,
   236,   237,    43,   199,    48,   241,   242,   128,   202,    38,
   241,   242,   123,   124,   126,   127,   129,   130,   131,   132,
    99,   100,    65,    50,   108,   109,   120,   375,   376,   110,
   111,   112,   113,   114,   115,   116,   117,   196,   196,   205,
   377,   387,   427,    49,   433,    50,   147,   148,   149,   150,
   196,   388,   196,   437,   196,   206,   445,   209,   447,   450,
    43,   251,    48,   196,   252,   128,   196,    38,   196,   196,
   123,   124,   126,   127,   129,   130,   131,   132,    99,   100,
    65,    50,   108,   109,   120,   454,   253,   110,   111,   112,
   113,   114,   115,   116,   117,   196,    34,    35,    36,   243,
   244,    49,    49,    50,   147,   148,   149,   150,    34,    35,
    36,   243,   244,   254,    49,   245,   246,   247,   248,    67,
    48,   243,   244,   128,   268,    38,   243,   244,   123,   124,
   126,   127,   129,   130,   131,   132,    99,   100,    65,    50,
   108,   109,   120,   249,   250,   110,   111,   112,   113,   114,
   115,   116,   117,   245,   246,   247,   248,   271,   272,    49,
   275,    50,   147,   148,   149,   150,   245,   246,   247,   248,
   285,   296,   192,   303,   307,   308,   314,   315,   277,    50,
    50,   128,    50,    38,   353,   355,   123,   124,   126,   127,
   129,   130,   131,   132,    99,   100,    65,    50,   108,   109,
   120,   357,    50,   110,   111,   112,   113,   114,   115,   116,
   117,   378,   389,   390,   251,   281,   252,    49,   253,    50,
   147,   148,   149,   150,   254,   395,   396,   397,   398,   399,
   405,   406,   384,   384,   423,   424,   425,   426,   442,   128,
   nil,    38,   nil,   nil,   123,   124,   126,   127,   129,   130,
   131,   132,    99,   100,    65,    50,   108,   109,   120,   nil,
   nil,   110,   111,   112,   113,   114,   115,   116,   117,   nil,
   nil,   nil,   nil,   nil,   nil,   nil,   nil,    50,   147,   148,
   149,   150,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,   nil,   nil,   nil,   128,   nil,    38,
   nil,   nil,   123,   124,   126,   127,   129,   130,   131,   132,
    99,   100,    65,   nil,   108,   109,   120,   nil,   nil,   110,
   111,   112,   113,   114,   115,   116,   117,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,   nil,    50,   147,   148,   149,   150,
   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,   nil,   128,   nil,    38,   nil,   nil,
   123,   124,   126,   127,   129,   130,   131,   132,    99,   100,
    65,   nil,   108,   109,   120,   nil,   nil,   110,   111,   112,
   113,   114,   115,   116,   117,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,   nil,    50,   147,   148,   149,   150,   nil,   nil,
   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,   nil,   128,   nil,    38,   nil,   nil,   123,   124,
   126,   127,   129,   130,   131,   132,    99,   100,    65,   nil,
   108,   109,   120,   nil,   nil,   110,   111,   112,   113,   114,
   115,   116,   117,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,    50,   147,   148,   149,   150,   nil,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   128,   nil,    38,   nil,   nil,   123,   124,   126,   127,
   129,   130,   131,   132,    99,   100,    65,   nil,   108,   109,
   120,   nil,   nil,   110,   111,   112,   113,   114,   115,   116,
   117,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,    50,
   147,   148,   149,   150,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   128,
   nil,    38,   nil,   nil,   123,   124,   126,   127,   129,   130,
   131,   132,    99,   100,    65,   nil,   108,   109,   120,   nil,
   nil,   110,   111,   112,   113,   114,   115,   116,   117,   nil,
   nil,   nil,   nil,   nil,   nil,   nil,   nil,    50,   147,   148,
   149,   150,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,   nil,   nil,   nil,   128,   nil,    38,
   nil,   nil,   123,   124,   126,   127,   129,   130,   131,   132,
    99,   100,    65,   nil,   108,   109,   120,   nil,   nil,   110,
   111,   112,   113,   114,   115,   116,   117,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,   nil,    50,   147,   148,   149,   150,
   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,   nil,   128,   nil,    38,   nil,   nil,
   123,   124,   126,   127,   129,   130,   131,   132,    99,   100,
    65,   nil,   108,   109,   120,   nil,   nil,   110,   111,   112,
   113,   114,   115,   116,   117,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,